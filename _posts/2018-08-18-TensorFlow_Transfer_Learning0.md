---
layout: post
title: "[Deep Learning] Transfer Learning"
tags: [tensorflow, transfer learning, 테스트]
comments: true
---

.

# Transfer Learning

개인적으로 서비스에 적용할 모델 학습을 진행할 때, 데이터가 부족한 경우를 많이 만나왔습니다. 그때마다 저를 포함해서 딥러닝 공부한 사람들이 주로 하는 답변은 "`Transfer Learning`을 하면 돼" 였습니다. 그렇지만 최근 들어서 개인적으로 딥러닝을 바라보는 관점이 조금씩 바뀌어 가며 과연 이는 제대로 된 답변이였나 그리고 만약 맞는 답변이라고 하더라도 상황에 따른 판단 근거가 있는 상태에서의 대답이였나를 다시 한번 곱씹어 보게 되었습니다.

`Transfer Learning`을 매우 간단히 말하자면, 이미 학습된 즉 `Pre-trained`인 모델을 기반으로 해서 우리가 풀고자 하는 (보통은) 새로운 문제(도메인)에 대한 데이터를 가지고 추가적인 학습을 진행하거나 다른 용도로 사용하는 것을 의미합니다.

앞서 언급했다시피 이에 대한 이해를 제대로 하고 있는지, 그 기준을 잘 알고 있는지를 스스로 한번 정리해보기 위해 이번 글에서는 [CS 231 Transfer Learning](http://cs231n.github.io/transfer-learning/) 에 대한 내용을 기반으로 정리해보려 합니다. 이 글은 Vision 강의의 일환으로 작성되었으므로 주로 CNN에 기반한 내용을 소개함을 미리 밝혀둡니다.

실제로 뉴럴넷 모델 학습을 진행할 때, 생각보다 weight를 랜덤하게 초기화한 상태에서 CNN 네트워크 전체를 학습시키는 경우는 적습니다. 아무래도 충분한 데이터 셋이 존재하지 않는다는 점을 그 이유로 들 수 있을 텐데요 (~~최근에는 대량의 데이터가 존재하기는 하지만~~). 그래서 대신에 보통 ImageNet(1.2m 이미지로 학습된) 과 같은 이미 학습된 네트워크를 이용하고, `weight 초기화`나 `고정된 길이의 feature extractor`과 같이 필요한 방식대로 사용하곤 합니다. 아래에서는 3가지의 Transfer Learning 시나리오를 소개하고자 합니다.

- **ConvNet을 고정된 길이의 Feature Extractor로 쓰는 경우**. ImageNet을 이용해서 이미 학습된 ConvNet을 사용하는 경우에 Conv layer의 output을 1000 개의 클래스로 매핑해주는 역할을 하는 `fully-connected layer`을 제거할 수 있습니다. 이렇게 되면 이 ConvNet을 단순히 새로운 데이터셋에 대해서 고정된 길이의 Feature를 뽑아내는 추출기라고 생각할 수 있습니다. AlexNet의 경우에 마지막의 classifier만 떼어낸, 즉 hidden layer의 activation function까지 거친 feature로 표현될 것이고 이 feature는 4096차원의 벡터로 표현될 것입니다. 우리는 이를 **CNN codes**라고 부릅니다. 퍼포먼스의 측면에서 이 벡터가 ReLU(activation function)을 거쳤다는 것이 중요합니다. 일단 4096 차원의 코드로 모든 이미지들을 표현할 수 있다면 새로운 데이터셋에 대해서 Linear SVM이나 Softmax classifier와 같은 선형 분류기를 학습시킬 수 있습니다.

- **ConvNet을 Fine-tuning하는 경우**. 이것은 두 번째 전략으로 새로운 데이터 셋에 대해서 단순히 ConvNet 위에 있는 classifier를 바꿔치기하거나 새로 학습시키는 것이 아니라 backpropagation을 진행해서 이미 학습된 네트워크의 weight를 `fine-tune`하는 방식입니다. 이 방식을 택할 경우 말 그대로 ConvNet의 모든 레이어들을 fine-tuning할 수도 있고, 오버피팅을 막기 위해 초기 레이어들의 weight는 고정시켜놓고, 뒤따라오는 레이어들의 weight를 fine-tuning할 수도 있습니다. 후자의 경우에는 ConvNet이 실제로 초기 레이어들은 일반적인 피쳐들(edge detectors / color blob detector)을 학습하고 상위의 레이어로 갈수록 데이터셋에 포함된 더 상세한 디테일들을 학습해 나간다는 것에 기반한 의사 결정입니다.
- **이미 학습된 모델들 (Pretrained models)**. 이 경우는 학습된 모델 자체를 사용하는 경우입니다. ImageNet과 같은 현 시점에서 성능이 가장 좋은 ConvNet들은 다중 GPU 분산처리를 한다고 해도 학습시키는데 2~3주 가량이 걸립니다. 그러나 고맙게도 우리가 이미 학습된 네트워크를 이용해서 `fine-tun ing`을 진행할 수 잇도록 자신들이 학습시킨 모델의 마지막 checkpoint들을 공개해주는 사람들을 쉽게 찾을 수 있습니다. 예를 들어서 Caffe 라이브러리는 사람들이 자신들 네트워크의 weight를 공유할 수 있는 `Model Zoo`를 가지고 있습니다.

위에서 알아본 것처럼 세 가지 use-case가 있다면 언제 그리고 어떻게 `fine-tune`을 진행해야 할까요?

이에 대해서 여러 고려요소들이 있을 수 있지만, 그 중에서도 가장 중요한 두 가지 요소가 있습니다. 바로 `새로운 데이터셋의 크기`와 `기존 학습에 사용되었던 데이터셋과 새로운 데이터셋 사이의 유사도`입니다. 그리고 다시 한 번 언급하자면, ConvNet은 기본적으로 일반적인 feature들을 초기 레이어들에서 잡아내고 `original-dataset-specific`한 feature들을 상위 레이어들에서 잡아냅니다. 이런 정보를 기반으로 해서 경험적으로 알려진 4가지 주요 시나리오들을 소개합니다.

1. **새로운 데이터셋의 크기가 작고 기존 학습 데이터셋과 유사한 경우**. 새로운 데이터 셋이 작기 때문에 ConvNet에 대한 Fine-tuning을 진행하는 것은 오버피팅 문제 때문에 그렇게 좋은 선택이 아닙니다 (소수의 데이터가 특징으로 작용해서 네트워크가 그 특징에서 집중해서 학습할 가능성). 데이터 유사성의 측면에서 보면, 상위 레벨의 feature들이 기존의 데이터 셋과 유사할 것이기 때문에 CNN 코드를 이용해서 linear classifier을 학습시키는 것이 바람직한 선택입니다.
2.  **새로운 데이터셋이 크고 기존 학습 데이터셋과 유사한 경우**. 데이터셋의 크기가 크기 때문에 오버피팅에 대한 걱정을 덜고 전체 네트워크에 대한 fine-tuning을 진행할 수 있습니다.
3. **새로운 데이터셋이 작고 기존 학습 데이터셋과 다른 경우**. 데이터셋의 크기가 작기 때문에 앞서 언급했던 linear classifier에 대한 학습을 진행하는 것이 바람직합니다. 또한, 데이터셋의 유사성 관점에서는 classifier가 새로운 데이터셋에 적합된 feature들을 학습할 가능성이 크기 때문에 classifier를 학습시키는 것은 그리 바람직하지 않습니다. 대신에 네트워크의 몇 개 레이어를 거슬러가서  SVM classifier를 학습시키는 것이 바람직합니다.
4. **새로운 데이터셋이 크고 기존 학습 데이터셋과 다른 경우**. 데이터셋이 매우 크기 때문에 ConvNet을 새로 학습시킬 수 있습니다. 그러나 실제 적용하는 경우 Pretrained 모델의 weight를 이용해서 학습을 진행하는 것의 장점을 활용하곤 합니다. 이 경우에는 전체 네트워크에 대한 fine-tune을 진행해도 될만큼의 충분한 데이터와 확신을 가질 수 있습니다.

추가적으로 `Transfer Learning`을 진행하는 데에 있어 고려할 만한 두 가지가 있습니다.

- **Pretrained 모델을 사용함으로써 생기는 제약들**. 우리가 이미 학습된 네트워크를 사용하고자 한다면 새로운 데이터셋을 적용하려고 할 때 그 데이터의 구조에 있어서 약간의 제약을 받을 수 있습니다 .예를 들어 이미 학습된 네트워크의 Conv layer를 임의로 꺼낼 수 없습니다. 그러나 그 외에 몇 가지 변형은 충분히 가능합니다. 먼저 파라미터를 공유하기 때문에 이미 학습된 네트워크를 다른 공간 크기의 이미지에 대해서도 사용할 수 있습니다. 이는 Conv/Pool 레이어들이 feed-forward를 진행하는 경우에 input volume spatial 크기에 대해서 독립적이기 때문입니다. FC 레이어의 경우에도 FC 레이어가 Conv 레이어로 변환될 수 있으므로 똑같이 적용됩니다. 예를 들어 AlexNet의 경우 첫 번째 FC 레이어 전의 마지막 풀링 레이어의 크기는 `(6x6x512)`입니다. 그로므로 이 볼륨을 바라보고 있는 FC 레이어는 6x6의 `receptive field`를 가지고 padding은 0인 Conv 레이어를 가지고 있는 것과 동일합니다.

- **Learning rates**. 무작위로 초기화된 weight들을 가지고 새로운 데이터셋에 대한 class score를 계산하기 위한 linear classifier를 학습시키는 경우랑 비교했을 때, 보통 Fine-tuning을 진행할 때는 더 작은 `learning rate`를 사용합니다. 이는 이미 학습된 ConvNet의 weight가 상대적으로 좋고 우리가 추가적인 fine-tuning을 진행함으로 해서 이것이 너무 빨리 그리고 너무 많이 왜곡되기를 원하지 않기 때문입니다.



이렇게 `Transfer Learning`의 기준 및 use-case에 대해서 알아보았습니다. 이 글 외에도 추가적인 소스들이 있어서 이에 대한 내용들은 이어지는 글에서 정리하도록 하겠습니다.

**틀린 내용이나 추가할 내용에 대해서는 댓글 남겨주시면 반영하겠습니다.**

.
